<!DOCTYPE html>
<html lang="en">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>py3d</title>

<div id=PY#D_ID>
</div>
<script>
	{
		const data = PY#D_ARGS
		class ToolBar {
			constructor() {
				this.enable = false
				this.bar = document.createElement("div")
				this.btn_enable = document.createElement("button")
				this.btn_enable.innerHTML = "ctrl"
				this.btn_enable.style.width = "30px"
				this.btn_enable.style.height = "20px"
				this.btn_enable.style.border = "0px"
				this.btn_enable.style.borderRadius = "3px"
				this.btn_zoom_in = document.createElement("button")
				this.btn_zoom_in.innerHTML = "+"
				this.btn_zoom_in.style.width = "20px"
				this.btn_zoom_in.style.height = "20px"
				this.btn_zoom_in.style.border = "0px"
				this.btn_zoom_in.style.borderRadius = "3px"
				this.btn_zoom_in.style.display = "none"
				this.btn_zoom_out = document.createElement("button")
				this.btn_zoom_out.innerHTML = "-"
				this.btn_zoom_out.style.width = "20px"
				this.btn_zoom_out.style.height = "20px"
				this.btn_zoom_out.style.border = "0px"
				this.btn_zoom_out.style.borderRadius = "3px"
				this.btn_zoom_out.style.display = "none"
				this.tooltip = document.createElement("div")
				this.tooltip.innerHTML = `
				pan:  ctrl+mouse move<br/>
				zoom: mouse wheel
				`
				this.tooltip.style.display = "none"
				this.btn_enable.onclick = (ev) => {
					if (this.enable) {
						this.btn_zoom_in.style.display = "none"
						this.btn_zoom_out.style.display = "none"
						this.tooltip.style.display = "none"
						this.enable = false
						this.btn_enable.style.backgroundColor = ""
					} else {
						this.btn_zoom_in.style.display = "inline"
						this.btn_zoom_out.style.display = "inline"
						this.tooltip.style.display = "block"
						this.btn_enable.style.backgroundColor = "gray"
						this.enable = true
					}
				}
				this.bar.append(this.btn_enable, this.btn_zoom_in, this.btn_zoom_out, this.tooltip)
			}
		}
		class mat {
			static identity() {
				return [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1]
			}
			static right_to_left() {
				return [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, -1, 0,
					0, 0, 0, 1]
			}
			static orthographic(l, r, t, b, n, f) {
				return [
					2 / (r - l), 0, 0, 0,
					0, 2 / (t - b), 0, 0,
					0, 0, 2 / (n - f), 0,
					(l + r) / (l - r), (t + b) / (b - t), (n + f) / (f - n), 1]
			}
			static perspective(fovy, aspect, near, far) {
				const f = 1 / Math.tan(fovy / 2)
				const range_inv = 1.0 / (near - far)
				return [
					f / aspect, 0, 0, 0,
					0, f, 0, 0,
					0, 0, (near + far) * range_inv, 1,
					0, 0, -2 * near * far * range_inv, 0]
			}
			static translation(x, y, z) {
				return [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					x, y, z, 1]
			}
			static rz(a) {
				const cos = Math.cos(a)
				const sin = Math.sin(a)
				return [
					cos, sin, 0, 0,
					-sin, cos, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1]
			}
			static ry(a) {
				const cos = Math.cos(a)
				const sin = Math.sin(a)
				return [
					cos, 0, -sin, 0,
					0, 1, 0, 0,
					sin, 0, cos, 0,
					0, 0, 0, 1]
			}
			static rx(a) {
				const cos = Math.cos(a)
				const sin = Math.sin(a)
				return [
					1, 0, 0, 0,
					0, cos, sin, 0,
					0, -sin, cos, 0,
					0, 0, 0, 1]
			}
			static matmul(m, v) {
				console.assert(m.length == 16 && v.length == 4, m, v)
				let ret = []
				for (let j of [0, 1, 2, 3]) {
					ret.push(m[j] * v[0] + m[j + 4] * v[1] + m[j + 8] * v[2] + m[j + 12] * v[3])
				}
				return ret
			}
		}
		class Camera {
			PESPECTIVE = 0
			ORTHOGRAPHIC = 1
			constructor(fovy, aspect, near, far) {
				this.type = this.PESPECTIVE
				this.projection = mat.perspective(fovy, aspect, near, far)
				this.height = 10
				this.ry = 0
				this.latitude = 0
				this.center = []
			}
		}
		class Viewer {
			constructor() {
				this.canvas_x = 0
				this.canvas_y = 0
				this.canvas = document.createElement("canvas")
				this.canvas.style.width = "400px"
				this.canvas.style.height = "300px"
				this.canvas.width = 400
				this.canvas.height = 300
				this.canvas.style.outlineWidth = 0
				this.camera = new Camera(Math.PI / 3, 4 / 3, 1, 100)
				this.camera.height = -10
				this.camera.ry = 0
				this.camera.rx = 0
				this.toolbar = new ToolBar()
				document.getElementById("PY#D_ID").append(this.canvas, this.toolbar.bar)
				this.toolbar.btn_zoom_in.onclick = (ev) => {
					this.camera.height += 1
					this.render()
				}
				this.toolbar.btn_zoom_out.onclick = (ev) => {
					this.camera.height -= 1
					this.render()
				}
				this.canvas.onmouseenter = (ev) => {
					this.canvas_x = ev.clientX
					this.canvas_y = ev.clientY
					this.canvas.tabIndex = 0
					this.canvas.focus()
				}
				this.canvas.onmousemove = (ev) => {
					if (this.toolbar.enable) {
						this.camera.ry += (ev.clientX - this.canvas_x) / 100
						this.camera.rx += (ev.clientY - this.canvas_y) / 100
						this.render()
					}
					this.canvas_x = ev.clientX
					this.canvas_y = ev.clientY
				}
				this.canvas.onwheel = (ev) => {
					if (this.toolbar.enable) {
						ev.preventDefault()
						this.camera.height -= ev.deltaY / 100
						this.render()
					}
				}
				this.canvas.onkeydown = (ev) => {
					if (!this.toolbar.enable) {
						this.toolbar.btn_enable.click()
					}
				}
				this.canvas.onkeyup = (ev) => {
					if (this.toolbar.enable) {
						this.toolbar.btn_enable.click()
					}
				}
				this.gl = this.canvas.getContext("webgl")
				if (!this.gl) {
					alert("webgl not work")
				}
				this.program = this.gl.createProgram()
				this.vertices_size = 0
			}
			set_attribute(name, array, item_size) {
				const buffer = this.gl.createBuffer()
				this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer)
				this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(array), this.gl.STATIC_DRAW)
				const location = this.gl.getAttribLocation(this.program, name)
				this.gl.enableVertexAttribArray(location)
				this.gl.vertexAttribPointer(location, item_size, this.gl.FLOAT, false, 0, 0)
				this.vertices_size = array.length / item_size
			}
			set_uniform(name, array) {
				const location = this.gl.getUniformLocation(this.program, name)
				this.gl.uniformMatrix4fv(location, false, array)
			}
			set_shader(type, code) {
				const shader = this.gl.createShader(type)
				this.gl.shaderSource(shader, code)
				this.gl.compileShader(shader)
				this.gl.attachShader(this.program, shader)
			}
			set_fragment_shader(code) {
				this.set_shader(this.gl.FRAGMENT_SHADER, code)
			}
			set_vertex_shader(code) {
				this.set_shader(this.gl.VERTEX_SHADER, code)
			}
			set_program(vertex_shader_code, fragment_shader_code) {
				this.set_vertex_shader(vertex_shader_code)
				this.set_fragment_shader(fragment_shader_code)
				this.gl.linkProgram(this.program)
				if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
					alert('Unable to initialize the shader program: ' + this.gl.getProgramInfoLog(this.program))
				}
			}
			render() {
				this.gl.clearColor(0, 0, 0, 0)
				// this.gl.clearDepth(1.0);                 // Clear everything
				this.gl.enable(this.gl.DEPTH_TEST);
				// this.gl.depthFunc(this.gl.LEQUAL);            // Near things obscure far things
				this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
				this.gl.useProgram(this.program)
				this.set_uniform("height_view", mat.translation(0, 0, -this.camera.height))
				this.set_uniform("longitude_view", mat.ry(-this.camera.ry))
				this.set_uniform("latitude_view", mat.rx(-this.camera.rx))
				this.set_uniform("projection", this.camera.projection)
				this.set_uniform("right_to_left", mat.right_to_left())
				for (let id in data) {
					let obj = data[id]
					this.set_attribute("position", obj.vertice, 3)
					this.set_attribute("color", obj.color, 4)
					this.gl.drawArrays(this.gl[obj.mode], 0, this.vertices_size)
				}
			}
		}
		const viewer = new Viewer()
		viewer.set_program(`
			attribute vec4 position;
			attribute vec4 color;
			varying vec4 v_color;
			uniform mat4 projection;
			uniform mat4 longitude_view;
			uniform mat4 latitude_view;
			uniform mat4 height_view;
			uniform mat4 right_to_left;
			void main(void) {
				v_color = color;
				gl_PointSize = 1.0;
				gl_Position = right_to_left * projection * height_view * latitude_view * longitude_view * right_to_left * position;
			}
		`, `
			precision mediump float;
			varying vec4 v_color;
			void main(void) {
				gl_FragColor = v_color;
			} 
		`)
		viewer.render()
	}
</script>

</html>