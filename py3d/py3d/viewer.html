<!DOCTYPE html>
<html lang="en">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>py3d</title>
<div id=PY#D_ID>
</div>
<script>
	{
		const cache = PY#D_ARGS
		class TimeBar {
			constructor() {
				this.bar = document.createElement("div")
				this.ts = Object.keys(cache)
				this.frames = Object.values(cache)
				this.current_frame = this.frames[this.frames.length - 1]
				this.slider = document.createElement("input")
				this.slider.type = "range"
				this.slider.style.width = "380px"
				this.slider.style.verticalAlign = "middle"
				this.slider.style.height = "2px"
				this.slider.min = 0
				this.slider.max = this.ts.length - 1
				this.slider.value = this.slider.min
				this.slider.style.display = "inline"
				this.time = document.createElement("div")
				this.time.style.display = "inline"
				this.time.innerHTML = this.ts[this.slider.value]
				this.bar.append(this.slider, this.time)
				this.bar.style.display = this.ts.length > 1 ? "block" : "none"
			}
		}
		class ToolBar {
			constructor() {
				this.bar = document.createElement("div")
				this.btn_help = document.createElement("button")
				this.btn_help.innerHTML = "?"
				this.btn_help.style.width = "20px"
				this.btn_help.style.height = "20px"
				this.btn_help.style.border = "none"
				this.btn_help.style.borderRadius = "10px"
				this.btn_help.style.padding = "0px"
				this.btn_help.style.marginRight = "1px"
				this.btn_orth = document.createElement("button")
				this.btn_orth.innerHTML = "P"
				this.btn_orth.style.width = "20px"
				this.btn_orth.style.height = "20px"
				this.btn_orth.style.border = "none"
				this.btn_orth.style.borderRadius = "2px"
				this.btn_orth.style.padding = "0px"
				this.btn_orth.style.marginRight = "1px"
				this.btn_reset = document.createElement("button")
				this.btn_reset.innerHTML = "‚ü∞"
				this.btn_reset.style.width = "20px"
				this.btn_reset.style.height = "20px"
				this.btn_reset.style.border = "none"
				this.btn_reset.style.borderRadius = "2px"
				this.btn_reset.style.padding = "0px"
				this.btn_reset.style.marginRight = "1px"
				this.tooltip = document.createElement("div")
				this.tooltip.innerHTML = `
				rotate: press left mouse button and move<br/>
				zoom: mouse wheel<br/>
				`
				this.tooltip.style.display = "none"
				this.btn_help.onclick = (ev) => {
					if (this.btn_help.style.backgroundColor) {
						this.tooltip.style.display = "none"
						this.btn_help.style.backgroundColor = ""
					} else {
						this.tooltip.style.display = "block"
						this.btn_help.style.backgroundColor = "gray"
					}
				}
				this.bar.append(this.btn_help, this.btn_orth, this.btn_reset, this.tooltip)
			}
		}
		class mat {
			static identity() {
				return [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1]
			}
			static right_to_left() {
				return [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, -1, 0,
					0, 0, 0, 1]
			}
			static orthographic(fovy, aspect, near, far, distance) {
				return [
					1 / aspect / distance / Math.tan(fovy / 2), 0, 0, 0,
					0, 1 / distance / Math.tan(fovy / 2), 0, 0,
					0, 0, 2 / (near - far), 0,
					0, 0, (near + far) / (far - near), 1]
			}
			static perspective(fovy, aspect, near, far) {
				const f = 1 / Math.tan(fovy / 2)
				const range_inv = 1.0 / (near - far)
				return [
					f / aspect, 0, 0, 0,
					0, f, 0, 0,
					0, 0, (near + far) * range_inv, 1,
					0, 0, -2 * near * far * range_inv, 0]
			}
			static translation(x, y, z) {
				return [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					x, y, z, 1]
			}
			static rz(a) {
				const cos = Math.cos(a)
				const sin = Math.sin(a)
				return [
					cos, sin, 0, 0,
					-sin, cos, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1]
			}
			static ry(a) {
				const cos = Math.cos(a)
				const sin = Math.sin(a)
				return [
					cos, 0, -sin, 0,
					0, 1, 0, 0,
					sin, 0, cos, 0,
					0, 0, 0, 1]
			}
			static rx(a) {
				const cos = Math.cos(a)
				const sin = Math.sin(a)
				return [
					1, 0, 0, 0,
					0, cos, sin, 0,
					0, -sin, cos, 0,
					0, 0, 0, 1]
			}
			static matmul(m, v) {
				console.assert(m.length == 16 && v.length == 4, m, v)
				let ret = []
				for (let j of [0, 1, 2, 3]) {
					ret.push(m[j] * v[0] + m[j + 4] * v[1] + m[j + 8] * v[2] + m[j + 12] * v[3])
				}
				return ret
			}
		}
		class Utils {
			static distance(x0, y0, x1, y1) {
				x1 = x1 ? x1 : 0
				y1 = y1 ? y1 : 0
				return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2))
			}
		}
		class Camera {
			PERSPECTIVE = 0
			ORTHOGRAPHIC = 1
			constructor(fovy, aspect, near, far) {
				this.type = this.PERSPECTIVE
				this.fovy = fovy
				this.aspect = aspect
				this.near = near
				this.far = far
				this.projection = mat.perspective(fovy, aspect, near, far)
				this.height = -10
				this.rx = 0
				this.ry = 0
				this.center = []
			}
			set_orthographic() {
				this.projection = mat.orthographic(this.fovy, this.aspect, this.near, this.far, Math.abs(this.height))
				this.type = this.ORTHOGRAPHIC
			}
			set_perspective() {
				this.projection = mat.perspective(this.fovy, this.aspect, this.near, this.far)
				this.type = this.PERSPECTIVE
			}
			reset() {
				this.height = -10
				this.rx = 0
				this.ry = 0
				if (this.type == this.ORTHOGRAPHIC) {
					this.set_orthographic()
				}
			}
		}
		class Viewer {
			constructor() {
				this.canvas_x = 0
				this.canvas_y = 0
				this.canvas = document.createElement("canvas")
				this.canvas.style.width = "400px"
				this.canvas.style.height = "300px"
				this.canvas.width = 400
				this.canvas.height = 300
				this.canvas.style.outlineWidth = 0
				this.camera = new Camera(Math.PI / 3, 4 / 3, 1, 100)
				this.toolbar = new ToolBar()
				this.timebar = new TimeBar()
				document.getElementById("PY#D_ID").append(this.canvas, this.timebar.bar, this.toolbar.bar)
				this.canvas.onmouseenter = (ev) => {
					this.canvas_x = ev.clientX
					this.canvas_y = ev.clientY
					this.canvas.tabIndex = 0
					this.canvas.focus()
				}
				this.canvas.onmousemove = (ev) => {
					if (ev.buttons == 1) {
						this.camera.rx += (ev.clientY - this.canvas_y) / 100
						this.camera.ry += (ev.clientX - this.canvas_x) / 100
						this.render()
					}
					this.canvas_x = ev.clientX
					this.canvas_y = ev.clientY
				}
				this.canvas.onwheel = (ev) => {
					ev.preventDefault()
					this.camera.height -= ev.deltaY / 100
					if (this.camera.type == this.camera.ORTHOGRAPHIC) {
						this.camera.set_orthographic()
					}
					this.render()
				}
				this.toolbar.btn_orth.onclick = (ev) => {
					if (this.camera.type == this.camera.ORTHOGRAPHIC) {
						this.camera.set_perspective()
						this.render()
						this.toolbar.btn_orth.innerHTML = "P"
					} else {
						this.camera.set_orthographic()
						this.render()
						this.toolbar.btn_orth.innerHTML = "O"
					}
				}
				this.toolbar.btn_reset.onclick = (ev) => {
					this.camera.reset()
					this.render()
				}
				this.timebar.slider.oninput = (ev) => {
					this.timebar.current_frame = this.timebar.frames[this.timebar.slider.value]
					this.timebar.time.innerHTML = this.timebar.ts[this.timebar.slider.value]
					this.render()
				}
				this.gl = this.canvas.getContext("webgl")
				if (!this.gl) {
					alert("webgl not work")
				}
				this.program = this.gl.createProgram()
				this.vertices_size = 0
			}
			set_attribute(name, array, item_size) {
				const buffer = this.gl.createBuffer()
				this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer)
				this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(array), this.gl.STATIC_DRAW)
				const location = this.gl.getAttribLocation(this.program, name)
				this.gl.enableVertexAttribArray(location)
				this.gl.vertexAttribPointer(location, item_size, this.gl.FLOAT, false, 0, 0)
				this.vertices_size = array.length / item_size
			}
			set_uniform(name, array) {
				const location = this.gl.getUniformLocation(this.program, name)
				this.gl.uniformMatrix4fv(location, false, array)
			}
			set_shader(type, code) {
				const shader = this.gl.createShader(type)
				this.gl.shaderSource(shader, code)
				this.gl.compileShader(shader)
				this.gl.attachShader(this.program, shader)
			}
			set_program(vertex_shader_code, fragment_shader_code) {
				this.set_shader(this.gl.VERTEX_SHADER, vertex_shader_code)
				this.set_shader(this.gl.FRAGMENT_SHADER, fragment_shader_code)
				this.gl.linkProgram(this.program)
				if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
					alert('Unable to initialize the shader program: ' + this.gl.getProgramInfoLog(this.program))
				}
			}
			render() {
				this.gl.clearColor(0, 0, 0, 0)
				// this.gl.clearDepth(1.0);                 // Clear everything
				this.gl.enable(this.gl.DEPTH_TEST);
				// this.gl.depthFunc(this.gl.LEQUAL);            // Near things obscure far things
				this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
				this.gl.useProgram(this.program)
				this.set_uniform("height_view", mat.translation(0, 0, -this.camera.height))
				this.set_uniform("rx_view", mat.rx(-this.camera.rx))
				this.set_uniform("ry_view", mat.ry(-this.camera.ry))
				this.set_uniform("projection", this.camera.projection)
				this.set_uniform("right_to_left", mat.right_to_left())
				for (let obj of this.timebar.current_frame) {
					this.set_attribute("position", obj.vertex, 3)
					this.set_attribute("color", obj.color, 4)
					this.gl.drawArrays(this.gl[obj.mode], 0, this.vertices_size)
				}
			}
		}
		const viewer = new Viewer()
		viewer.set_program(`
			attribute vec4 position;
			attribute vec4 color;
			varying vec4 v_color;
			uniform mat4 projection;
			uniform mat4 rx_view;
			uniform mat4 ry_view;
			uniform mat4 height_view;
			uniform mat4 right_to_left;
			void main(void) {
				v_color = color;
				gl_PointSize = 1.0;
				gl_Position = right_to_left * projection * height_view * rx_view * ry_view * right_to_left * position;
			}
		`, `
			precision mediump float;
			varying vec4 v_color;
			void main(void) {
				gl_FragColor = v_color;
			} 
		`)
		viewer.render()
	}
</script>

</html>