<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>ScenarioViewer</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="module">
        import * as THREE from './js/three.js';
        import { OrbitControls } from './js/orbit.js';
        var objs =new Map()
        var scene = new THREE.Scene();
        scene.background = new THREE.Color(0xF8F8FF)
        var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.up.set(0, 0, 1)
        camera.position.set(10, 10, 10)
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        var light = new THREE.PointLight(0xffffff, 1);
        light.position.set(10, 10, 10)

        var gridHelper = new THREE.GridHelper(10, 10);
        gridHelper.rotation.set(Math.PI / 2, 0, 0)
        scene.add(gridHelper, light);

        var axesHelper = new THREE.AxesHelper(5)
        axesHelper.material.linewidth = 2
        scene.add(axesHelper)

        var controls = new OrbitControls(camera, renderer.domElement);

        var animate = function () {
            light.position.copy(camera.position)
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        };

        animate();
        function Cube() {
            var geometry = new THREE.BoxGeometry();
            var material = new THREE.MeshLambertMaterial({ transparent: true});
            var cube = new THREE.Mesh(geometry, material);
            scene.add(cube)
            return cube
        }
        function Sphere(radius) {
            var geometry = new THREE.SphereGeometry(1, 32, 32);
            var material = new THREE.MeshLambertMaterial({ transparent: true, color: 0x00ff00 });
            var obj = new THREE.Mesh(geometry, material);
            obj.scale.set(radius, radius, radius)
            scene.add(obj);
            return obj
        }
        function Line() {
            var material = new THREE.LineBasicMaterial({
                color: 0x0000ff
            });
            var geometry = new THREE.BufferGeometry();
            var positions = new Float32Array(500 * 3); // 3 vertices per point
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setDrawRange(0, 0);
            var line = new THREE.Line(geometry, material);
            scene.add(line);
            return line
        }
        var ws = new WebSocket("ws://127.0.0.1:52330");

        ws.onopen = function (evt) {
            console.log("Connection open ...");
        };

        ws.onmessage = function (msg) {
            console.log(msg.data)
            var message = JSON.parse(msg.data)
            if(message.id)
            {
                var obj;
                if(objs.has(message.id))
                {
                    obj=objs.get(message.id)
                }
                else{
                    obj=new_object(message.class)
                    objs.set(message.id,obj)
                }
                update(message,obj)
            }
        }
        function new_object(cl){
            switch(cl)
            {
                case "Cube":
                    return Cube()
                case "Sphere":
                    return Sphere()
                default:
                    return null
            }
        }
        function update(message,obj) {
            var position=message.pose.position
            var rotation=message.pose.rotation
            var scale=message.pose.scale
            obj.position.set(position[0],position[1],position[2])
            obj.rotation.set(rotation[0],rotation[1],rotation[2])
            obj.scale.set(scale[0],scale[1],scale[2])
            obj.material.color.setRGB(message.color.r,message.color.g,message.color.b)
            obj.material.opacity = message.color.a
        }

        function handleLine(message) {
            var argvs = message.argvs
            switch (message.method) {
                case "__init__":
                    var id = Line()
                    ws.send(id)
                    break
                case "points":
                    var geometry = scene.getObjectById(message.id).geometry
                    var positions = geometry.attributes.position.array
                    if (argvs == "") {
                        var points = new Array
                        for (var i = geometry.drawRange.start; i < geometry.drawRange.count; i++) {
                            points.push([positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]])
                        }
                        ws.send(JSON.stringify(points))
                    } else {
                        for (var i = 0; i < argvs.length; i++) {
                            var position = argvs[i]
                            positions[i * 3] = position[0]
                            positions[i * 3 + 1] = position[1]
                            positions[i * 3 + 2] = position[2]
                        }
                        geometry.setDrawRange(0, argvs.length)
                        geometry.attributes.position.needsUpdate = true
                    }
                    break
                case "linewidth":
                    var material = scene.getObjectById(message.id).material
                    if (argvs == "") {
                        ws.send(material.linewidth)
                    } else {
                        material.linewidth = argvs
                    }
                default:
                    handleObject3D(message)
                    break
            }
        }
    </script>
</body>

</html>